# Telemetry

The telemetry system for our solar car was barely functional when I joined the team. The previous authors had created a Python Flask web application using a Redis database backend for storing data and a third program which read CAN messages from the car and stored them in the database. This version required you to reload the page if you want updated data to appear as they never got WebSockets working correctly. I had just finished CPRE 288, now had an in-depth knowledge of WebSockets, and the prior authors were graduating, so I got the project.

One major limitation of the system is the telemetry unit is a CANect HED Telematics system which runs a custom build of linux on a relatively low-powered processor. Due to the architecture of the car, Telem bridges two CAN networks in the car, and some messages that it has to pass between the networks require reliability (displaying a fault status on the dashboard, etc.), so it cannot fail randomly. The weight of running a python web application with a full Redis database and a separate program for reading CAN messages was a very dangerous situation because there is only so much processing power on this device and we weren't using most of the features of any of these frameworks. I rewrote the server with real-time data transfer in mind, using pure C++ for the backend ([ÂµWebSockets library](https://github.com/uNetworking/uWebSockets)) and a Vue.JS frontend to display the data. The C++ server runs in a tight event loop, making full use of kernel events to only process when new data arrives from a web client or the CAN bus. The Redis database was removed and replaced with a simple binary log file, and it worked happily. When running normally, `top` shows that the current telem application uses 0% CPU on average because it only runs when the kernel has an event for it to process.

Now, as I prepare to leave the team in a year, I am working to hand this project over to a group of new members who are learning C++, WebSockets, and frontend web development. This is a hard project to get started on because it is a combination of embedded development which requires knowledge of resources and computing efficiently, but also has a large web development portion which takes a very opposite mindset of flexibility over efficiency for the frontend.

[< Back to Projects](/projects)